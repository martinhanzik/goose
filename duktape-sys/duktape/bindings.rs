/* automatically generated by rust-bindgen */

pub const DUK_VERSION: ::std::os::raw::c_uint = 20200;
pub const DUK_GIT_COMMIT: &'static [u8; 41usize] =
    b"a459cf3c9bd1779fc01b435d69302b742675a08f\x00";
pub const DUK_GIT_DESCRIBE: &'static [u8; 7usize] = b"v2.2.0\x00";
pub const DUK_GIT_BRANCH: &'static [u8; 7usize] = b"master\x00";
pub const TARGET_OS_MAC: ::std::os::raw::c_uint = 1;
pub const TARGET_OS_WIN32: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_UNIX: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_OSX: ::std::os::raw::c_uint = 1;
pub const TARGET_OS_IPHONE: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_IOS: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_WATCH: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_BRIDGE: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_TV: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_SIMULATOR: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_EMBEDDED: ::std::os::raw::c_uint = 0;
pub const TARGET_IPHONE_SIMULATOR: ::std::os::raw::c_uint = 0;
pub const TARGET_OS_NANO: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_PPC: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_PPC64: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_68K: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_X86: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_X86_64: ::std::os::raw::c_uint = 1;
pub const TARGET_CPU_ARM: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_ARM64: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_MIPS: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_SPARC: ::std::os::raw::c_uint = 0;
pub const TARGET_CPU_ALPHA: ::std::os::raw::c_uint = 0;
pub const TARGET_RT_MAC_CFM: ::std::os::raw::c_uint = 0;
pub const TARGET_RT_MAC_MACHO: ::std::os::raw::c_uint = 1;
pub const TARGET_RT_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1;
pub const TARGET_RT_BIG_ENDIAN: ::std::os::raw::c_uint = 0;
pub const TARGET_RT_64_BIT: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const BSD: ::std::os::raw::c_uint = 199506;
pub const BSD4_3: ::std::os::raw::c_uint = 1;
pub const BSD4_4: ::std::os::raw::c_uint = 1;
pub const NeXTBSD: ::std::os::raw::c_uint = 1995064;
pub const NeXTBSD4_0: ::std::os::raw::c_uint = 0;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __DARWIN_NBBY: ::std::os::raw::c_uint = 8;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 266;
pub const GID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 1024;
pub const MAX_INPUT: ::std::os::raw::c_uint = 1024;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 16;
pub const UID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const OPEN_MAX: ::std::os::raw::c_uint = 10240;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const MAXCOMLEN: ::std::os::raw::c_uint = 16;
pub const MAXINTERP: ::std::os::raw::c_uint = 64;
pub const MAXLOGNAME: ::std::os::raw::c_uint = 255;
pub const MAXUPRC: ::std::os::raw::c_uint = 266;
pub const NCARGS: ::std::os::raw::c_uint = 262144;
pub const NGROUPS: ::std::os::raw::c_uint = 16;
pub const NOFILE: ::std::os::raw::c_uint = 256;
pub const NOGROUP: ::std::os::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 256;
pub const MAXDOMNAMELEN: ::std::os::raw::c_uint = 256;
pub const NBPG: ::std::os::raw::c_uint = 4096;
pub const PGOFSET: ::std::os::raw::c_uint = 4095;
pub const PGSHIFT: ::std::os::raw::c_uint = 12;
pub const DEV_BSIZE: ::std::os::raw::c_uint = 512;
pub const DEV_BSHIFT: ::std::os::raw::c_uint = 9;
pub const BLKDEV_IOSIZE: ::std::os::raw::c_uint = 2048;
pub const MAXPHYS: ::std::os::raw::c_uint = 131072;
pub const CLSIZE: ::std::os::raw::c_uint = 1;
pub const CLSIZELOG2: ::std::os::raw::c_uint = 0;
pub const MSIZESHIFT: ::std::os::raw::c_uint = 8;
pub const MSIZE: ::std::os::raw::c_uint = 256;
pub const MCLSHIFT: ::std::os::raw::c_uint = 11;
pub const MCLBYTES: ::std::os::raw::c_uint = 2048;
pub const MBIGCLSHIFT: ::std::os::raw::c_uint = 12;
pub const MBIGCLBYTES: ::std::os::raw::c_uint = 4096;
pub const M16KCLSHIFT: ::std::os::raw::c_uint = 14;
pub const M16KCLBYTES: ::std::os::raw::c_uint = 16384;
pub const MCLOFSET: ::std::os::raw::c_uint = 2047;
pub const NMBCLUSTERS: ::std::os::raw::c_uint = 512;
pub const __DARWIN_CLK_TCK: ::std::os::raw::c_uint = 100;
pub const CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 6;
pub const CLK_TCK: ::std::os::raw::c_uint = 100;
pub const SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CHAR_MIN: ::std::os::raw::c_int = -128;
pub const USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 512;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 8192;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_SS_REPL_MAX: ::std::os::raw::c_uint = 4;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 30;
pub const _POSIX_TRACE_NAME_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_SYS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: ::std::os::raw::c_uint = 128;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 9;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 14;
pub const NL_MSGMAX: ::std::os::raw::c_uint = 32767;
pub const NL_NMAX: ::std::os::raw::c_uint = 1;
pub const NL_SETMAX: ::std::os::raw::c_uint = 255;
pub const NL_TEXTMAX: ::std::os::raw::c_uint = 2048;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _XOPEN_PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101204;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const PSWP: ::std::os::raw::c_uint = 0;
pub const PVM: ::std::os::raw::c_uint = 4;
pub const PINOD: ::std::os::raw::c_uint = 8;
pub const PRIBIO: ::std::os::raw::c_uint = 16;
pub const PVFS: ::std::os::raw::c_uint = 20;
pub const PZERO: ::std::os::raw::c_uint = 22;
pub const PSOCK: ::std::os::raw::c_uint = 24;
pub const PWAIT: ::std::os::raw::c_uint = 32;
pub const PLOCK: ::std::os::raw::c_uint = 36;
pub const PPAUSE: ::std::os::raw::c_uint = 40;
pub const PUSER: ::std::os::raw::c_uint = 50;
pub const MAXPRI: ::std::os::raw::c_uint = 127;
pub const PRIMASK: ::std::os::raw::c_uint = 255;
pub const PCATCH: ::std::os::raw::c_uint = 256;
pub const PTTYBLOCK: ::std::os::raw::c_uint = 512;
pub const PDROP: ::std::os::raw::c_uint = 1024;
pub const PSPIN: ::std::os::raw::c_uint = 2048;
pub const CMASK: ::std::os::raw::c_uint = 18;
pub const CLBYTES: ::std::os::raw::c_uint = 4096;
pub const CLOFSET: ::std::os::raw::c_uint = 4095;
pub const CLOFF: ::std::os::raw::c_uint = 4095;
pub const CLSHIFT: ::std::os::raw::c_uint = 12;
pub const CBLOCK: ::std::os::raw::c_uint = 64;
pub const CBQSIZE: ::std::os::raw::c_uint = 8;
pub const CROUND: ::std::os::raw::c_uint = 63;
pub const MAXBSIZE: ::std::os::raw::c_uint = 1048576;
pub const MAXPHYSIO: ::std::os::raw::c_uint = 131072;
pub const MAXFRAG: ::std::os::raw::c_uint = 8;
pub const MAXPHYSIO_WIRED: ::std::os::raw::c_uint = 16777216;
pub const MAXPATHLEN: ::std::os::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::std::os::raw::c_uint = 32;
pub const MINBUCKET: ::std::os::raw::c_uint = 4;
pub const MAXALLOCSAVE: ::std::os::raw::c_uint = 8192;
pub const FSHIFT: ::std::os::raw::c_uint = 11;
pub const FSCALE: ::std::os::raw::c_uint = 2048;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const CLOCKS_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const DUK_USE_OS_STRING: &'static [u8; 4usize] = b"osx\x00";
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _JBLEN: ::std::os::raw::c_uint = 37;
pub const FP_NAN: ::std::os::raw::c_uint = 1;
pub const FP_INFINITE: ::std::os::raw::c_uint = 2;
pub const FP_ZERO: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 5;
pub const FP_SUPERNORMAL: ::std::os::raw::c_uint = 6;
pub const FP_ILOGB0: ::std::os::raw::c_int = -2147483648;
pub const FP_ILOGBNAN: ::std::os::raw::c_int = -2147483648;
pub const MATH_ERRNO: ::std::os::raw::c_uint = 1;
pub const MATH_ERREXCEPT: ::std::os::raw::c_uint = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: ::std::os::raw::c_uint = 1;
pub const FP_QNAN: ::std::os::raw::c_uint = 1;
pub const DOMAIN: ::std::os::raw::c_uint = 1;
pub const SING: ::std::os::raw::c_uint = 2;
pub const OVERFLOW: ::std::os::raw::c_uint = 3;
pub const UNDERFLOW: ::std::os::raw::c_uint = 4;
pub const TLOSS: ::std::os::raw::c_uint = 5;
pub const PLOSS: ::std::os::raw::c_uint = 6;
pub const DUK_USE_ARCH_STRING: &'static [u8; 4usize] = b"x64\x00";
pub const DUK_USE_BYTEORDER: ::std::os::raw::c_uint = 1;
pub const DUK_USE_ALIGN_BY: ::std::os::raw::c_uint = 1;
pub const DUK_USE_COMPILER_STRING: &'static [u8; 6usize] = b"clang\x00";
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\x00";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const PRId8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIo8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRId16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIi16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIo16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIu16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIx16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIX16: &'static [u8; 3usize] = b"hX\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRId64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIi64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIo64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIu64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIx64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIX64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNd64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNi64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNo64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNu64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNx64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const DUK_UINT8_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const DUK_INT8_MIN: ::std::os::raw::c_int = -128;
pub const DUK_INT8_MAX: ::std::os::raw::c_uint = 127;
pub const DUK_UINT_LEAST8_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const DUK_INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const DUK_INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const DUK_UINT_FAST8_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const DUK_INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const DUK_INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const DUK_UINT16_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const DUK_INT16_MIN: ::std::os::raw::c_int = -32768;
pub const DUK_INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const DUK_UINT_LEAST16_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const DUK_INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const DUK_INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const DUK_UINT_FAST16_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const DUK_INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const DUK_INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const DUK_UINT32_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UINT_LEAST32_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UINT_FAST32_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UINT64_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT64_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const DUK_INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const DUK_UINT_LEAST64_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INT_LEAST64_MIN: ::std::os::raw::c_longlong =
    -9223372036854775808;
pub const DUK_INT_LEAST64_MAX: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const DUK_UINT_FAST64_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INT_FAST64_MIN: ::std::os::raw::c_longlong =
    -9223372036854775808;
pub const DUK_INT_FAST64_MAX: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const DUK_UINTPTR_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const DUK_INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const DUK_UINTMAX_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const DUK_INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const DUK_SIZE_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_SIZE_MAX: ::std::os::raw::c_int = -1;
pub const DUK_INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UINT_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_INT_FAST_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_INT_FAST_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UINT_FAST_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UINT_FAST_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_SMALL_INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_SMALL_INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_SMALL_UINT_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_SMALL_UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_SMALL_INT_FAST_MIN: ::std::os::raw::c_int = -32768;
pub const DUK_SMALL_INT_FAST_MAX: ::std::os::raw::c_uint = 32767;
pub const DUK_SMALL_UINT_FAST_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_SMALL_UINT_FAST_MAX: ::std::os::raw::c_uint = 65535;
pub const DUK_BOOL_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_BOOL_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_IDX_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_IDX_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UIDX_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UIDX_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_UARRIDX_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UARRIDX_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_RET_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_RET_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_ERRCODE_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_ERRCODE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_CODEPOINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const DUK_CODEPOINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const DUK_UCODEPOINT_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_UCODEPOINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const DUK_FP_NAN: ::std::os::raw::c_uint = 1;
pub const DUK_FP_INFINITE: ::std::os::raw::c_uint = 2;
pub const DUK_FP_ZERO: ::std::os::raw::c_uint = 3;
pub const DUK_FP_SUBNORMAL: ::std::os::raw::c_uint = 5;
pub const DUK_FP_NORMAL: ::std::os::raw::c_uint = 4;
pub const DUK_USE_CALLSTACK_LIMIT: ::std::os::raw::c_uint = 10000;
pub const DUK_USE_COMPILER_RECLIMIT: ::std::os::raw::c_uint = 2500;
pub const DUK_USE_DEBUG_BUFSIZE: ::std::os::raw::c_uint = 65536;
pub const DUK_USE_DEBUG_LEVEL: ::std::os::raw::c_uint = 0;
pub const DUK_USE_ESBC_MAX_BYTES: ::std::os::raw::c_uint = 2147418112;
pub const DUK_USE_ESBC_MAX_LINENUMBER: ::std::os::raw::c_uint = 2147418112;
pub const DUK_USE_FATAL_MAXLEN: ::std::os::raw::c_uint = 128;
pub const DUK_USE_HOBJECT_ARRAY_ABANDON_LIMIT: ::std::os::raw::c_uint = 2;
pub const DUK_USE_HOBJECT_ARRAY_FAST_RESIZE_LIMIT: ::std::os::raw::c_uint = 9;
pub const DUK_USE_HOBJECT_ARRAY_MINGROW_ADD: ::std::os::raw::c_uint = 16;
pub const DUK_USE_HOBJECT_ARRAY_MINGROW_DIVISOR: ::std::os::raw::c_uint = 8;
pub const DUK_USE_HOBJECT_ENTRY_MINGROW_ADD: ::std::os::raw::c_uint = 16;
pub const DUK_USE_HOBJECT_ENTRY_MINGROW_DIVISOR: ::std::os::raw::c_uint = 8;
pub const DUK_USE_HOBJECT_HASH_PROP_LIMIT: ::std::os::raw::c_uint = 8;
pub const DUK_USE_JSON_DEC_RECLIMIT: ::std::os::raw::c_uint = 1000;
pub const DUK_USE_JSON_ENC_RECLIMIT: ::std::os::raw::c_uint = 1000;
pub const DUK_USE_MARK_AND_SWEEP_RECLIMIT: ::std::os::raw::c_uint = 256;
pub const DUK_USE_NATIVE_CALL_RECLIMIT: ::std::os::raw::c_uint = 1000;
pub const DUK_USE_REGEXP_COMPILER_RECLIMIT: ::std::os::raw::c_uint = 10000;
pub const DUK_USE_REGEXP_EXECUTOR_RECLIMIT: ::std::os::raw::c_uint = 10000;
pub const DUK_USE_ROM_PTRCOMP_FIRST: ::std::os::raw::c_uint = 63488;
pub const DUK_USE_STRHASH_SKIP_SHIFT: ::std::os::raw::c_uint = 5;
pub const DUK_USE_STRTAB_GROW_LIMIT: ::std::os::raw::c_uint = 17;
pub const DUK_USE_STRTAB_MAXSIZE: ::std::os::raw::c_uint = 268435456;
pub const DUK_USE_STRTAB_MINSIZE: ::std::os::raw::c_uint = 1024;
pub const DUK_USE_STRTAB_RESIZE_CHECK_MASK: ::std::os::raw::c_uint = 255;
pub const DUK_USE_STRTAB_SHRINK_LIMIT: ::std::os::raw::c_uint = 6;
pub const DUK_USE_TARGET_INFO: &'static [u8; 8usize] = b"unknown\x00";
pub const DUK_USE_TRACEBACK_DEPTH: ::std::os::raw::c_uint = 10;
pub const DUK_USE_VALSTACK_GROW_SHIFT: ::std::os::raw::c_uint = 2;
pub const DUK_USE_VALSTACK_LIMIT: ::std::os::raw::c_uint = 1000000;
pub const DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT: ::std::os::raw::c_uint = 2;
pub const DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT: ::std::os::raw::c_uint = 4;
pub const DUK_DEBUG_PROTOCOL_VERSION: ::std::os::raw::c_uint = 2;
pub const DUK_INVALID_INDEX: ::std::os::raw::c_int = -2147483648;
pub const DUK_API_ENTRY_STACK: ::std::os::raw::c_uint = 64;
pub const DUK_TYPE_MIN: ::std::os::raw::c_uint = 0;
pub const DUK_TYPE_NONE: ::std::os::raw::c_uint = 0;
pub const DUK_TYPE_UNDEFINED: ::std::os::raw::c_uint = 1;
pub const DUK_TYPE_NULL: ::std::os::raw::c_uint = 2;
pub const DUK_TYPE_BOOLEAN: ::std::os::raw::c_uint = 3;
pub const DUK_TYPE_NUMBER: ::std::os::raw::c_uint = 4;
pub const DUK_TYPE_STRING: ::std::os::raw::c_uint = 5;
pub const DUK_TYPE_OBJECT: ::std::os::raw::c_uint = 6;
pub const DUK_TYPE_BUFFER: ::std::os::raw::c_uint = 7;
pub const DUK_TYPE_POINTER: ::std::os::raw::c_uint = 8;
pub const DUK_TYPE_LIGHTFUNC: ::std::os::raw::c_uint = 9;
pub const DUK_TYPE_MAX: ::std::os::raw::c_uint = 9;
pub const DUK_TYPE_MASK_NONE: ::std::os::raw::c_uint = 1;
pub const DUK_TYPE_MASK_UNDEFINED: ::std::os::raw::c_uint = 2;
pub const DUK_TYPE_MASK_NULL: ::std::os::raw::c_uint = 4;
pub const DUK_TYPE_MASK_BOOLEAN: ::std::os::raw::c_uint = 8;
pub const DUK_TYPE_MASK_NUMBER: ::std::os::raw::c_uint = 16;
pub const DUK_TYPE_MASK_STRING: ::std::os::raw::c_uint = 32;
pub const DUK_TYPE_MASK_OBJECT: ::std::os::raw::c_uint = 64;
pub const DUK_TYPE_MASK_BUFFER: ::std::os::raw::c_uint = 128;
pub const DUK_TYPE_MASK_POINTER: ::std::os::raw::c_uint = 256;
pub const DUK_TYPE_MASK_LIGHTFUNC: ::std::os::raw::c_uint = 512;
pub const DUK_TYPE_MASK_THROW: ::std::os::raw::c_uint = 1024;
pub const DUK_TYPE_MASK_PROMOTE: ::std::os::raw::c_uint = 2048;
pub const DUK_HINT_NONE: ::std::os::raw::c_uint = 0;
pub const DUK_HINT_STRING: ::std::os::raw::c_uint = 1;
pub const DUK_HINT_NUMBER: ::std::os::raw::c_uint = 2;
pub const DUK_ENUM_INCLUDE_NONENUMERABLE: ::std::os::raw::c_uint = 1;
pub const DUK_ENUM_INCLUDE_HIDDEN: ::std::os::raw::c_uint = 2;
pub const DUK_ENUM_INCLUDE_SYMBOLS: ::std::os::raw::c_uint = 4;
pub const DUK_ENUM_EXCLUDE_STRINGS: ::std::os::raw::c_uint = 8;
pub const DUK_ENUM_OWN_PROPERTIES_ONLY: ::std::os::raw::c_uint = 16;
pub const DUK_ENUM_ARRAY_INDICES_ONLY: ::std::os::raw::c_uint = 32;
pub const DUK_ENUM_SORT_ARRAY_INDICES: ::std::os::raw::c_uint = 64;
pub const DUK_ENUM_NO_PROXY_BEHAVIOR: ::std::os::raw::c_uint = 128;
pub const DUK_COMPILE_EVAL: ::std::os::raw::c_uint = 8;
pub const DUK_COMPILE_FUNCTION: ::std::os::raw::c_uint = 16;
pub const DUK_COMPILE_STRICT: ::std::os::raw::c_uint = 32;
pub const DUK_COMPILE_SHEBANG: ::std::os::raw::c_uint = 64;
pub const DUK_COMPILE_SAFE: ::std::os::raw::c_uint = 128;
pub const DUK_COMPILE_NORESULT: ::std::os::raw::c_uint = 256;
pub const DUK_COMPILE_NOSOURCE: ::std::os::raw::c_uint = 512;
pub const DUK_COMPILE_STRLEN: ::std::os::raw::c_uint = 1024;
pub const DUK_COMPILE_NOFILENAME: ::std::os::raw::c_uint = 2048;
pub const DUK_COMPILE_FUNCEXPR: ::std::os::raw::c_uint = 4096;
pub const DUK_DEFPROP_WRITABLE: ::std::os::raw::c_uint = 1;
pub const DUK_DEFPROP_ENUMERABLE: ::std::os::raw::c_uint = 2;
pub const DUK_DEFPROP_CONFIGURABLE: ::std::os::raw::c_uint = 4;
pub const DUK_DEFPROP_HAVE_WRITABLE: ::std::os::raw::c_uint = 8;
pub const DUK_DEFPROP_HAVE_ENUMERABLE: ::std::os::raw::c_uint = 16;
pub const DUK_DEFPROP_HAVE_CONFIGURABLE: ::std::os::raw::c_uint = 32;
pub const DUK_DEFPROP_HAVE_VALUE: ::std::os::raw::c_uint = 64;
pub const DUK_DEFPROP_HAVE_GETTER: ::std::os::raw::c_uint = 128;
pub const DUK_DEFPROP_HAVE_SETTER: ::std::os::raw::c_uint = 256;
pub const DUK_DEFPROP_FORCE: ::std::os::raw::c_uint = 512;
pub const DUK_DEFPROP_SET_WRITABLE: ::std::os::raw::c_uint = 9;
pub const DUK_DEFPROP_CLEAR_WRITABLE: ::std::os::raw::c_uint = 8;
pub const DUK_DEFPROP_SET_ENUMERABLE: ::std::os::raw::c_uint = 18;
pub const DUK_DEFPROP_CLEAR_ENUMERABLE: ::std::os::raw::c_uint = 16;
pub const DUK_DEFPROP_SET_CONFIGURABLE: ::std::os::raw::c_uint = 36;
pub const DUK_DEFPROP_CLEAR_CONFIGURABLE: ::std::os::raw::c_uint = 32;
pub const DUK_DEFPROP_W: ::std::os::raw::c_uint = 1;
pub const DUK_DEFPROP_E: ::std::os::raw::c_uint = 2;
pub const DUK_DEFPROP_C: ::std::os::raw::c_uint = 4;
pub const DUK_DEFPROP_WE: ::std::os::raw::c_uint = 3;
pub const DUK_DEFPROP_WC: ::std::os::raw::c_uint = 5;
pub const DUK_DEFPROP_WEC: ::std::os::raw::c_uint = 7;
pub const DUK_DEFPROP_HAVE_W: ::std::os::raw::c_uint = 8;
pub const DUK_DEFPROP_HAVE_E: ::std::os::raw::c_uint = 16;
pub const DUK_DEFPROP_HAVE_C: ::std::os::raw::c_uint = 32;
pub const DUK_DEFPROP_HAVE_WE: ::std::os::raw::c_uint = 24;
pub const DUK_DEFPROP_HAVE_WC: ::std::os::raw::c_uint = 40;
pub const DUK_DEFPROP_HAVE_WEC: ::std::os::raw::c_uint = 56;
pub const DUK_DEFPROP_SET_W: ::std::os::raw::c_uint = 9;
pub const DUK_DEFPROP_SET_E: ::std::os::raw::c_uint = 18;
pub const DUK_DEFPROP_SET_C: ::std::os::raw::c_uint = 36;
pub const DUK_DEFPROP_SET_WE: ::std::os::raw::c_uint = 27;
pub const DUK_DEFPROP_SET_WC: ::std::os::raw::c_uint = 45;
pub const DUK_DEFPROP_SET_WEC: ::std::os::raw::c_uint = 63;
pub const DUK_DEFPROP_CLEAR_W: ::std::os::raw::c_uint = 8;
pub const DUK_DEFPROP_CLEAR_E: ::std::os::raw::c_uint = 16;
pub const DUK_DEFPROP_CLEAR_C: ::std::os::raw::c_uint = 32;
pub const DUK_DEFPROP_CLEAR_WE: ::std::os::raw::c_uint = 24;
pub const DUK_DEFPROP_CLEAR_WC: ::std::os::raw::c_uint = 40;
pub const DUK_DEFPROP_CLEAR_WEC: ::std::os::raw::c_uint = 56;
pub const DUK_DEFPROP_ATTR_W: ::std::os::raw::c_uint = 57;
pub const DUK_DEFPROP_ATTR_E: ::std::os::raw::c_uint = 58;
pub const DUK_DEFPROP_ATTR_C: ::std::os::raw::c_uint = 60;
pub const DUK_DEFPROP_ATTR_WE: ::std::os::raw::c_uint = 59;
pub const DUK_DEFPROP_ATTR_WC: ::std::os::raw::c_uint = 61;
pub const DUK_DEFPROP_ATTR_WEC: ::std::os::raw::c_uint = 63;
pub const DUK_THREAD_NEW_GLOBAL_ENV: ::std::os::raw::c_uint = 1;
pub const DUK_GC_COMPACT: ::std::os::raw::c_uint = 1;
pub const DUK_ERR_NONE: ::std::os::raw::c_uint = 0;
pub const DUK_ERR_ERROR: ::std::os::raw::c_uint = 1;
pub const DUK_ERR_EVAL_ERROR: ::std::os::raw::c_uint = 2;
pub const DUK_ERR_RANGE_ERROR: ::std::os::raw::c_uint = 3;
pub const DUK_ERR_REFERENCE_ERROR: ::std::os::raw::c_uint = 4;
pub const DUK_ERR_SYNTAX_ERROR: ::std::os::raw::c_uint = 5;
pub const DUK_ERR_TYPE_ERROR: ::std::os::raw::c_uint = 6;
pub const DUK_ERR_URI_ERROR: ::std::os::raw::c_uint = 7;
pub const DUK_RET_ERROR: ::std::os::raw::c_int = -1;
pub const DUK_RET_EVAL_ERROR: ::std::os::raw::c_int = -2;
pub const DUK_RET_RANGE_ERROR: ::std::os::raw::c_int = -3;
pub const DUK_RET_REFERENCE_ERROR: ::std::os::raw::c_int = -4;
pub const DUK_RET_SYNTAX_ERROR: ::std::os::raw::c_int = -5;
pub const DUK_RET_TYPE_ERROR: ::std::os::raw::c_int = -6;
pub const DUK_RET_URI_ERROR: ::std::os::raw::c_int = -7;
pub const DUK_EXEC_SUCCESS: ::std::os::raw::c_uint = 0;
pub const DUK_EXEC_ERROR: ::std::os::raw::c_uint = 1;
pub const DUK_LEVEL_DEBUG: ::std::os::raw::c_uint = 0;
pub const DUK_LEVEL_DDEBUG: ::std::os::raw::c_uint = 1;
pub const DUK_LEVEL_DDDEBUG: ::std::os::raw::c_uint = 2;
pub const DUK_BUF_FLAG_DYNAMIC: ::std::os::raw::c_uint = 1;
pub const DUK_BUF_FLAG_EXTERNAL: ::std::os::raw::c_uint = 2;
pub const DUK_BUF_FLAG_NOZERO: ::std::os::raw::c_uint = 4;
pub const DUK_BUFOBJ_ARRAYBUFFER: ::std::os::raw::c_uint = 0;
pub const DUK_BUFOBJ_NODEJS_BUFFER: ::std::os::raw::c_uint = 1;
pub const DUK_BUFOBJ_DATAVIEW: ::std::os::raw::c_uint = 2;
pub const DUK_BUFOBJ_INT8ARRAY: ::std::os::raw::c_uint = 3;
pub const DUK_BUFOBJ_UINT8ARRAY: ::std::os::raw::c_uint = 4;
pub const DUK_BUFOBJ_UINT8CLAMPEDARRAY: ::std::os::raw::c_uint = 5;
pub const DUK_BUFOBJ_INT16ARRAY: ::std::os::raw::c_uint = 6;
pub const DUK_BUFOBJ_UINT16ARRAY: ::std::os::raw::c_uint = 7;
pub const DUK_BUFOBJ_INT32ARRAY: ::std::os::raw::c_uint = 8;
pub const DUK_BUFOBJ_UINT32ARRAY: ::std::os::raw::c_uint = 9;
pub const DUK_BUFOBJ_FLOAT32ARRAY: ::std::os::raw::c_uint = 10;
pub const DUK_BUFOBJ_FLOAT64ARRAY: ::std::os::raw::c_uint = 11;
pub const DUK_BUF_MODE_FIXED: ::std::os::raw::c_uint = 0;
pub const DUK_BUF_MODE_DYNAMIC: ::std::os::raw::c_uint = 1;
pub const DUK_BUF_MODE_DONTCARE: ::std::os::raw::c_uint = 2;
pub const DUK_DATE_MSEC_SECOND: ::std::os::raw::c_uint = 1000;
pub const DUK_DATE_MSEC_MINUTE: ::std::os::raw::c_uint = 60000;
pub const DUK_DATE_MSEC_HOUR: ::std::os::raw::c_uint = 3600000;
pub const DUK_DATE_MSEC_DAY: ::std::os::raw::c_uint = 86400000;
pub const DUK_DATE_MIN_ECMA_YEAR: ::std::os::raw::c_int = -271821;
pub const DUK_DATE_MAX_ECMA_YEAR: ::std::os::raw::c_uint = 275760;
pub const DUK_DATE_IDX_YEAR: ::std::os::raw::c_uint = 0;
pub const DUK_DATE_IDX_MONTH: ::std::os::raw::c_uint = 1;
pub const DUK_DATE_IDX_DAY: ::std::os::raw::c_uint = 2;
pub const DUK_DATE_IDX_HOUR: ::std::os::raw::c_uint = 3;
pub const DUK_DATE_IDX_MINUTE: ::std::os::raw::c_uint = 4;
pub const DUK_DATE_IDX_SECOND: ::std::os::raw::c_uint = 5;
pub const DUK_DATE_IDX_MILLISECOND: ::std::os::raw::c_uint = 6;
pub const DUK_DATE_IDX_WEEKDAY: ::std::os::raw::c_uint = 7;
pub const DUK_DATE_IDX_NUM_PARTS: ::std::os::raw::c_uint = 8;
pub const DUK_DATE_FLAG_NAN_TO_ZERO: ::std::os::raw::c_uint = 1;
pub const DUK_DATE_FLAG_NAN_TO_RANGE_ERROR: ::std::os::raw::c_uint = 2;
pub const DUK_DATE_FLAG_ONEBASED: ::std::os::raw::c_uint = 4;
pub const DUK_DATE_FLAG_EQUIVYEAR: ::std::os::raw::c_uint = 8;
pub const DUK_DATE_FLAG_LOCALTIME: ::std::os::raw::c_uint = 16;
pub const DUK_DATE_FLAG_SUB1900: ::std::os::raw::c_uint = 32;
pub const DUK_DATE_FLAG_TOSTRING_DATE: ::std::os::raw::c_uint = 64;
pub const DUK_DATE_FLAG_TOSTRING_TIME: ::std::os::raw::c_uint = 128;
pub const DUK_DATE_FLAG_TOSTRING_LOCALE: ::std::os::raw::c_uint = 256;
pub const DUK_DATE_FLAG_TIMESETTER: ::std::os::raw::c_uint = 512;
pub const DUK_DATE_FLAG_YEAR_FIXUP: ::std::os::raw::c_uint = 1024;
pub const DUK_DATE_FLAG_SEP_T: ::std::os::raw::c_uint = 2048;
pub const DUK_DATE_FLAG_VALUE_SHIFT: ::std::os::raw::c_uint = 12;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub const OSUnknownByteOrder: _bindgen_ty_1 =
    _bindgen_ty_1::OSUnknownByteOrder;
pub const OSLittleEndian: _bindgen_ty_1 = _bindgen_ty_1::OSLittleEndian;
pub const OSBigEndian: _bindgen_ty_1 = _bindgen_ty_1::OSBigEndian;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    OSUnknownByteOrder = 0,
    OSLittleEndian = 1,
    OSBigEndian = 2,
}
pub type NXSwappedFloat = ::std::os::raw::c_ulong;
pub type NXSwappedDouble = ::std::os::raw::c_ulonglong;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NXByteOrder {
    NX_UnknownByteOrder = 0,
    NX_LittleEndian = 1,
    NX_BigEndian = 2,
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_thread_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_thread_state>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_thread_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebx as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ecx as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ecx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edx as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edi as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esi as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esp as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ss as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eflags
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eip as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __cs as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ds as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __es as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __fs as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __gs as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __gs ) ));
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( __darwin_fp_control ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_control>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_fp_control ) ));
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 3072u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 3072u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __pc: ::std::os::raw::c_ushort,
                          __rc: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((__invalid as u16 as u16) <<
                                                     0usize) & (1u64 as u16))
                                       } |
                                           ((__denorm as u16 as u16) <<
                                                1usize) & (2u64 as u16))
                                  } |
                                      ((__zdiv as u16 as u16) << 2usize) &
                                          (4u64 as u16))
                             } |
                                 ((__ovrfl as u16 as u16) << 3usize) &
                                     (8u64 as u16))
                        } |
                            ((__undfl as u16 as u16) << 4usize) &
                                (16u64 as u16))
                   } | ((__precis as u16 as u16) << 5usize) & (32u64 as u16))
              } | ((__pc as u16 as u16) << 8usize) & (768u64 as u16))
         } | ((__rc as u16 as u16) << 10usize) & (3072u64 as u16))
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>() , 2usize , concat !
               ( "Size of: " , stringify ! ( __darwin_fp_status ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_status>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_fp_status ) ));
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 14336u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 14336u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __stkflt: ::std::os::raw::c_ushort,
                          __errsumm: ::std::os::raw::c_ushort,
                          __c0: ::std::os::raw::c_ushort,
                          __c1: ::std::os::raw::c_ushort,
                          __c2: ::std::os::raw::c_ushort,
                          __tos: ::std::os::raw::c_ushort,
                          __c3: ::std::os::raw::c_ushort,
                          __busy: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              0
                                                                          } |
                                                                              ((__invalid
                                                                                    as
                                                                                    u16
                                                                                    as
                                                                                    u16)
                                                                                   <<
                                                                                   0usize)
                                                                                  &
                                                                                  (1u64
                                                                                       as
                                                                                       u16))
                                                                     } |
                                                                         ((__denorm
                                                                               as
                                                                               u16
                                                                               as
                                                                               u16)
                                                                              <<
                                                                              1usize)
                                                                             &
                                                                             (2u64
                                                                                  as
                                                                                  u16))
                                                                } |
                                                                    ((__zdiv
                                                                          as
                                                                          u16
                                                                          as
                                                                          u16)
                                                                         <<
                                                                         2usize)
                                                                        &
                                                                        (4u64
                                                                             as
                                                                             u16))
                                                           } |
                                                               ((__ovrfl as
                                                                     u16 as
                                                                     u16) <<
                                                                    3usize) &
                                                                   (8u64 as
                                                                        u16))
                                                      } |
                                                          ((__undfl as u16 as
                                                                u16) <<
                                                               4usize) &
                                                              (16u64 as u16))
                                                 } |
                                                     ((__precis as u16 as u16)
                                                          << 5usize) &
                                                         (32u64 as u16))
                                            } |
                                                ((__stkflt as u16 as u16) <<
                                                     6usize) & (64u64 as u16))
                                       } |
                                           ((__errsumm as u16 as u16) <<
                                                7usize) & (128u64 as u16))
                                  } |
                                      ((__c0 as u16 as u16) << 8usize) &
                                          (256u64 as u16))
                             } |
                                 ((__c1 as u16 as u16) << 9usize) &
                                     (512u64 as u16))
                        } |
                            ((__c2 as u16 as u16) << 10usize) &
                                (1024u64 as u16))
                   } | ((__tos as u16 as u16) << 11usize) & (14336u64 as u16))
              } | ((__c3 as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((__busy as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mmst_reg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_rsrv as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_rsrv ) ));
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_xmm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_xmm_reg ) ) . __xmm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_xmm_reg ) ,
                "::" , stringify ! ( __xmm_reg ) ));
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_float_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_float_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_float_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
impl Clone for __darwin_i386_float_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>() , 716usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_avx_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv1
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ip as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_cs as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv2
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_dp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ds as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv3
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsr
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm0
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm1
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm2
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm3
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm4
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm5
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm6
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm7
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv4
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh0
                as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh1
                as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh2
                as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh3
                as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh4
                as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh5
                as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh6
                as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh7
                as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh7 ) ));
}
impl Clone for __darwin_i386_avx_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( __darwin_i386_exception_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_exception_state>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_exception_state
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __cpu
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __cpu )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __err
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __err )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state32>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr1 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr2 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr3 as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr4 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr5 as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr6 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr7 as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>() , 168usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_thread_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_thread_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_thread_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rax
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbx
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rcx
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rcx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdx
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdi
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsi
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbp
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsp
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r8 as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r9 as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r10
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r11
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r11 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r12
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r12 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r13
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r13 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r14
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r14 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r15
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r15 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rip
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) .
                __rflags as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rflags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __cs as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __fs as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __fs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __gs as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __gs )
                ));
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>() , 524usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_float_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_float_state64>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_float_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm8 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm9 as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
impl Clone for __darwin_x86_float_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>() , 844usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_avx_state64>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm8
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm9
                as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm15
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh15
                ) ));
}
impl Clone for __darwin_x86_avx_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_exception_state64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_exception_state64>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_exception_state64
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __cpu as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __cpu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __err as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __err
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr1 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr2 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr3 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr4 as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr5 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr6 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr7 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext32>() , 600usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext32 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __ss as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __fs as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx32>() , 792usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __ss as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __fs as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext_avx32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext64>() , 712usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __ss as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __fs as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx64>() , 1032usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __ss as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __fs as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext_avx64 {
    fn clone(&self) -> Self { *self }
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(::std::mem::size_of::<__darwin_sigaltstack>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_sigaltstack )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_sigaltstack>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_sp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_flags ) ));
}
impl Clone for __darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(::std::mem::size_of::<__darwin_ucontext>() , 56usize , concat !
               ( "Size of: " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (::std::mem::align_of::<__darwin_ucontext>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_onstack as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_sigmask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_stack as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_link as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcontext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcontext ) ));
}
impl Clone for __darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_function as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_attributes as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_attributes ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::std::mem::size_of::<__siginfo>() , 104usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::std::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_band as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . __pad as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       ::std::os::raw::c_int,
                                                                   arg2:
                                                                       *mut __siginfo,
                                                                   arg3:
                                                                       *mut ::std::os::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(::std::mem::size_of::<__sigaction_u>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __sigaction_u ) ));
    assert_eq! (::std::mem::align_of::<__sigaction_u>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_sigaction as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_sigaction ) ));
}
impl Clone for __sigaction_u {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(::std::mem::size_of::<__sigaction>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __sigaction ) ));
    assert_eq! (::std::mem::align_of::<__sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . __sigaction_u as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_tramp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_tramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for __sigaction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
pub type sig_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::std::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::std::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                        ::std::os::raw::c_int,
                                                    arg2:
                                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                       ::std::os::raw::c_int)>)>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(::std::mem::size_of::<timeval64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval64 ) ));
    assert_eq! (::std::mem::align_of::<timeval64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval64 ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval64 ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval64 ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval64 ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::std::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::std::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tickadj as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tickadj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, arg4: *const tm)
     -> usize;
}
extern "C" {
    pub fn strptime(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, arg3: *mut tm)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::std::os::raw::c_char, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "select$1050"]
    pub fn select(arg1: ::std::os::raw::c_int, arg2: *mut fd_set,
                  arg3: *mut fd_set, arg4: *mut fd_set, arg5: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(arg1: ::std::os::raw::c_int, arg2: *const itimerval,
                     arg3: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::std::os::raw::c_char, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(::std::mem::size_of::<rusage_info_v0>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
}
impl Clone for rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(::std::mem::size_of::<rusage_info_v1>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
}
impl Clone for rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(::std::mem::size_of::<rusage_info_v2>() , 160usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
}
impl Clone for rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(::std::mem::size_of::<rusage_info_v3>() , 232usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_default as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_maintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_background as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_utility as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_utility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_legacy as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_legacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_initiated as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_initiated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_interactive as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_interactive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_billed_system_time as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_billed_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_serviced_system_time as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_serviced_system_time ) ));
}
impl Clone for rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_current = rusage_info_v3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(::std::mem::size_of::<proc_rlimit_control_wakeupmon>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( proc_rlimit_control_wakeupmon ) ));
    assert_eq! (::std::mem::align_of::<proc_rlimit_control_wakeupmon>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( proc_rlimit_control_wakeupmon
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! (
                wm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_rate as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_rate
                ) ));
}
impl Clone for proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Termsig: ::std::os::raw::c_uint,
                          w_Coredump: ::std::os::raw::c_uint,
                          w_Retcode: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((w_Termsig as u32 as u32) << 0usize) &
                                (127u64 as u32))
                   } |
                       ((w_Coredump as u32 as u32) << 7usize) &
                           (128u64 as u32))
              } | ((w_Retcode as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Stopval: ::std::os::raw::c_uint,
                          w_Stopsig: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((w_Stopval as u32 as u32) << 0usize) &
                           (255u64 as u32))
              } | ((w_Stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_T as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_T ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_S as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_S ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nel: usize,
                   __width: usize,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtol(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(__str: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *const ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __overwrite: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void,
                          __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(__key: *const ::std::os::raw::c_void,
                     __base: *const ::std::os::raw::c_void, __nel: usize,
                     __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "daemon$1050"]
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                    __width: usize,
                    __compar:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                      __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                     __width: usize,
                     __compar:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                       __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn psort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn psort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn radixsort(__base: *mut *const ::std::os::raw::c_uchar,
                     __nel: ::std::os::raw::c_int,
                     __table: *const ::std::os::raw::c_uchar,
                     __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(__base: *mut *const ::std::os::raw::c_uchar,
                      __nel: ::std::os::raw::c_int,
                      __table: *const ::std::os::raw::c_uchar,
                      __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dst: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__b: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(__s1: *mut ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(__big: *const ::std::os::raw::c_char,
                  __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__str: *mut ::std::os::raw::c_char,
                  __sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(__str: *mut ::std::os::raw::c_char,
                    __sep: *const ::std::os::raw::c_char,
                    __lasts: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __strerrbuf: *mut ::std::os::raw::c_char,
                      __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(__s: *mut ::std::os::raw::c_void, __smax: rsize_t,
                    __c: ::std::os::raw::c_int, __n: rsize_t) -> errno_t;
}
extern "C" {
    pub fn memmem(__big: *const ::std::os::raw::c_void, __big_len: usize,
                  __little: *const ::std::os::raw::c_void,
                  __little_len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(__b: *mut ::std::os::raw::c_void,
                           __pattern4: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern8(__b: *mut ::std::os::raw::c_void,
                           __pattern8: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern16(__b: *mut ::std::os::raw::c_void,
                            __pattern16: *const ::std::os::raw::c_void,
                            __len: usize);
}
extern "C" {
    pub fn strcasestr(__big: *const ::std::os::raw::c_char,
                      __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(__big: *const ::std::os::raw::c_char,
                   __little: *const ::std::os::raw::c_char, __len: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int,
                   __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(arg1: *const ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void, arg3: isize);
}
extern "C" {
    pub fn timingsafe_bcmp(__b1: *const ::std::os::raw::c_void,
                           __b2: *const ::std::os::raw::c_void, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::std::os::raw::c_void,
                 arg2: *mut ::std::os::raw::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn index(arg1: *const ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int,
                   arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int,
                    arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sigsetjmp(arg1: *mut ::std::os::raw::c_int,
                     arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn longjmperror();
}
pub type max_align_t = f64;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __inff() -> f32;
}
extern "C" {
    pub fn __inf() -> f64;
}
extern "C" {
    pub fn __infl() -> f64;
}
extern "C" {
    pub fn __nan() -> f32;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(::std::mem::size_of::<__float2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __float2 ) ));
    assert_eq! (::std::mem::align_of::<__float2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __float2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __cosval as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __float2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(::std::mem::size_of::<__double2>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __double2 ) ));
    assert_eq! (::std::mem::align_of::<__double2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __double2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __cosval as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __double2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::std::mem::size_of::<exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( exception ) ));
    assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn matherr(arg1: *mut exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
pub type duk_uint8_t = u8;
pub type duk_int8_t = i8;
pub type duk_uint16_t = u16;
pub type duk_int16_t = i16;
pub type duk_uint32_t = u32;
pub type duk_int32_t = i32;
pub type duk_uint64_t = u64;
pub type duk_int64_t = i64;
pub type duk_uint_least8_t = uint_least8_t;
pub type duk_int_least8_t = int_least8_t;
pub type duk_uint_least16_t = uint_least16_t;
pub type duk_int_least16_t = int_least16_t;
pub type duk_uint_least32_t = uint_least32_t;
pub type duk_int_least32_t = int_least32_t;
pub type duk_uint_least64_t = uint_least64_t;
pub type duk_int_least64_t = int_least64_t;
pub type duk_uint_fast8_t = uint_fast8_t;
pub type duk_int_fast8_t = int_fast8_t;
pub type duk_uint_fast16_t = uint_fast16_t;
pub type duk_int_fast16_t = int_fast16_t;
pub type duk_uint_fast32_t = uint_fast32_t;
pub type duk_int_fast32_t = int_fast32_t;
pub type duk_uint_fast64_t = uint_fast64_t;
pub type duk_int_fast64_t = int_fast64_t;
pub type duk_uintptr_t = usize;
pub type duk_intptr_t = isize;
pub type duk_uintmax_t = uintmax_t;
pub type duk_intmax_t = intmax_t;
pub type duk_size_t = usize;
pub type duk_ptrdiff_t = isize;
pub type duk_int_t = ::std::os::raw::c_int;
pub type duk_uint_t = ::std::os::raw::c_uint;
pub type duk_int_fast_t = duk_int_fast32_t;
pub type duk_uint_fast_t = duk_uint_fast32_t;
pub type duk_small_int_t = ::std::os::raw::c_int;
pub type duk_small_uint_t = ::std::os::raw::c_uint;
pub type duk_small_int_fast_t = duk_int_fast16_t;
pub type duk_small_uint_fast_t = duk_uint_fast16_t;
pub type duk_bool_t = duk_small_uint_t;
pub type duk_idx_t = duk_int_t;
pub type duk_uidx_t = duk_uint_t;
pub type duk_uarridx_t = duk_uint_t;
pub type duk_ret_t = duk_small_int_t;
pub type duk_errcode_t = duk_int_t;
pub type duk_codepoint_t = duk_int_t;
pub type duk_ucodepoint_t = duk_uint_t;
pub type duk_float_t = f32;
pub type duk_double_t = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duk_hthread {
    _unused: [u8; 0],
}
pub type duk_context = duk_hthread;
#[repr(C)]
#[derive(Copy)]
pub struct duk_thread_state {
    pub data: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_duk_thread_state() {
    assert_eq!(::std::mem::size_of::<duk_thread_state>() , 128usize , concat !
               ( "Size of: " , stringify ! ( duk_thread_state ) ));
    assert_eq! (::std::mem::align_of::<duk_thread_state>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( duk_thread_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_thread_state ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_thread_state ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for duk_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct duk_memory_functions {
    pub alloc_func: duk_alloc_function,
    pub realloc_func: duk_realloc_function,
    pub free_func: duk_free_function,
    pub udata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duk_memory_functions() {
    assert_eq!(::std::mem::size_of::<duk_memory_functions>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( duk_memory_functions )
               ));
    assert_eq! (::std::mem::align_of::<duk_memory_functions>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( duk_memory_functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_memory_functions ) ) . alloc_func as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_memory_functions )
                , "::" , stringify ! ( alloc_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_memory_functions ) ) . realloc_func
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_memory_functions )
                , "::" , stringify ! ( realloc_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_memory_functions ) ) . free_func as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_memory_functions )
                , "::" , stringify ! ( free_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_memory_functions ) ) . udata as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_memory_functions )
                , "::" , stringify ! ( udata ) ));
}
impl Clone for duk_memory_functions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct duk_function_list_entry {
    pub key: *const ::std::os::raw::c_char,
    pub value: duk_c_function,
    pub nargs: duk_idx_t,
}
#[test]
fn bindgen_test_layout_duk_function_list_entry() {
    assert_eq!(::std::mem::size_of::<duk_function_list_entry>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( duk_function_list_entry ) ));
    assert_eq! (::std::mem::align_of::<duk_function_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( duk_function_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_function_list_entry ) ) . key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_function_list_entry
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_function_list_entry ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_function_list_entry
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_function_list_entry ) ) . nargs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_function_list_entry
                ) , "::" , stringify ! ( nargs ) ));
}
impl Clone for duk_function_list_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct duk_number_list_entry {
    pub key: *const ::std::os::raw::c_char,
    pub value: duk_double_t,
}
#[test]
fn bindgen_test_layout_duk_number_list_entry() {
    assert_eq!(::std::mem::size_of::<duk_number_list_entry>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( duk_number_list_entry )
               ));
    assert_eq! (::std::mem::align_of::<duk_number_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( duk_number_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_number_list_entry ) ) . key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_number_list_entry )
                , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_number_list_entry ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_number_list_entry )
                , "::" , stringify ! ( value ) ));
}
impl Clone for duk_number_list_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct duk_time_components {
    pub year: duk_double_t,
    pub month: duk_double_t,
    pub day: duk_double_t,
    pub hours: duk_double_t,
    pub minutes: duk_double_t,
    pub seconds: duk_double_t,
    pub milliseconds: duk_double_t,
    pub weekday: duk_double_t,
}
#[test]
fn bindgen_test_layout_duk_time_components() {
    assert_eq!(::std::mem::size_of::<duk_time_components>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( duk_time_components ) ));
    assert_eq! (::std::mem::align_of::<duk_time_components>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( duk_time_components ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . year as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . month as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( month ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . day as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( day ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . hours as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( hours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . minutes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( minutes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . seconds as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( seconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . milliseconds as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( milliseconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const duk_time_components ) ) . weekday as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( duk_time_components ) ,
                "::" , stringify ! ( weekday ) ));
}
impl Clone for duk_time_components {
    fn clone(&self) -> Self { *self }
}
pub type duk_c_function =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut duk_context)
                              -> duk_ret_t>;
pub type duk_alloc_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               size: duk_size_t)
                              -> *mut ::std::os::raw::c_void>;
pub type duk_realloc_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               size: duk_size_t)
                              -> *mut ::std::os::raw::c_void>;
pub type duk_free_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void)>;
pub type duk_fatal_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               msg:
                                                   *const ::std::os::raw::c_char)>;
pub type duk_decode_char_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               codepoint: duk_codepoint_t)>;
pub type duk_map_char_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               codepoint: duk_codepoint_t)
                              -> duk_codepoint_t>;
pub type duk_safe_call_function =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut duk_context,
                                               udata:
                                                   *mut ::std::os::raw::c_void)
                              -> duk_ret_t>;
pub type duk_debug_read_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               buffer:
                                                   *mut ::std::os::raw::c_char,
                                               length: duk_size_t)
                              -> duk_size_t>;
pub type duk_debug_write_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void,
                                               buffer:
                                                   *const ::std::os::raw::c_char,
                                               length: duk_size_t)
                              -> duk_size_t>;
pub type duk_debug_peek_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void)
                              -> duk_size_t>;
pub type duk_debug_read_flush_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void)>;
pub type duk_debug_write_flush_function =
    ::std::option::Option<unsafe extern "C" fn(udata:
                                                   *mut ::std::os::raw::c_void)>;
pub type duk_debug_request_function =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut duk_context,
                                               udata:
                                                   *mut ::std::os::raw::c_void,
                                               nvalues: duk_idx_t)
                              -> duk_idx_t>;
pub type duk_debug_detached_function =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut duk_context,
                                               udata:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn duk_create_heap(alloc_func: duk_alloc_function,
                           realloc_func: duk_realloc_function,
                           free_func: duk_free_function,
                           heap_udata: *mut ::std::os::raw::c_void,
                           fatal_handler: duk_fatal_function)
     -> *mut duk_context;
}
extern "C" {
    pub fn duk_destroy_heap(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_suspend(ctx: *mut duk_context, state: *mut duk_thread_state);
}
extern "C" {
    pub fn duk_resume(ctx: *mut duk_context, state: *const duk_thread_state);
}
extern "C" {
    pub fn duk_alloc_raw(ctx: *mut duk_context, size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_free_raw(ctx: *mut duk_context,
                        ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_realloc_raw(ctx: *mut duk_context,
                           ptr: *mut ::std::os::raw::c_void, size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_alloc(ctx: *mut duk_context, size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_free(ctx: *mut duk_context, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_realloc(ctx: *mut duk_context,
                       ptr: *mut ::std::os::raw::c_void, size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_memory_functions(ctx: *mut duk_context,
                                    out_funcs: *mut duk_memory_functions);
}
extern "C" {
    pub fn duk_gc(ctx: *mut duk_context, flags: duk_uint_t);
}
extern "C" {
    pub fn duk_throw_raw(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_fatal_raw(ctx: *mut duk_context,
                         err_msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn duk_error_raw(ctx: *mut duk_context, err_code: duk_errcode_t,
                         filename: *const ::std::os::raw::c_char,
                         line: duk_int_t,
                         fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn duk_error_va_raw(ctx: *mut duk_context, err_code: duk_errcode_t,
                            filename: *const ::std::os::raw::c_char,
                            line: duk_int_t,
                            fmt: *const ::std::os::raw::c_char,
                            ap: *mut __va_list_tag);
}
extern "C" {
    pub fn duk_is_strict_call(ctx: *mut duk_context) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_constructor_call(ctx: *mut duk_context) -> duk_bool_t;
}
extern "C" {
    pub fn duk_normalize_index(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_idx_t;
}
extern "C" {
    pub fn duk_require_normalize_index(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_idx_t;
}
extern "C" {
    pub fn duk_is_valid_index(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_require_valid_index(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_get_top(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_set_top(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_get_top_index(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_require_top_index(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_check_stack(ctx: *mut duk_context, extra: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_require_stack(ctx: *mut duk_context, extra: duk_idx_t);
}
extern "C" {
    pub fn duk_check_stack_top(ctx: *mut duk_context, top: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_require_stack_top(ctx: *mut duk_context, top: duk_idx_t);
}
extern "C" {
    pub fn duk_swap(ctx: *mut duk_context, idx1: duk_idx_t, idx2: duk_idx_t);
}
extern "C" {
    pub fn duk_swap_top(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_dup(ctx: *mut duk_context, from_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_dup_top(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_insert(ctx: *mut duk_context, to_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_replace(ctx: *mut duk_context, to_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_copy(ctx: *mut duk_context, from_idx: duk_idx_t,
                    to_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_remove(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_xcopymove_raw(to_ctx: *mut duk_context,
                             from_ctx: *mut duk_context, count: duk_idx_t,
                             is_copy: duk_bool_t);
}
extern "C" {
    pub fn duk_push_undefined(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_null(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_boolean(ctx: *mut duk_context, val: duk_bool_t);
}
extern "C" {
    pub fn duk_push_true(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_false(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_number(ctx: *mut duk_context, val: duk_double_t);
}
extern "C" {
    pub fn duk_push_nan(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_int(ctx: *mut duk_context, val: duk_int_t);
}
extern "C" {
    pub fn duk_push_uint(ctx: *mut duk_context, val: duk_uint_t);
}
extern "C" {
    pub fn duk_push_string(ctx: *mut duk_context,
                           str: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_push_lstring(ctx: *mut duk_context,
                            str: *const ::std::os::raw::c_char,
                            len: duk_size_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_push_pointer(ctx: *mut duk_context,
                            p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_push_sprintf(ctx: *mut duk_context,
                            fmt: *const ::std::os::raw::c_char, ...)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_push_vsprintf(ctx: *mut duk_context,
                             fmt: *const ::std::os::raw::c_char,
                             ap: *mut __va_list_tag)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_push_this(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_current_function(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_current_thread(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_global_object(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_heap_stash(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_global_stash(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_thread_stash(ctx: *mut duk_context,
                                 target_ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_object(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_bare_object(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_array(ctx: *mut duk_context) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_c_function(ctx: *mut duk_context, func: duk_c_function,
                               nargs: duk_idx_t) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_c_lightfunc(ctx: *mut duk_context, func: duk_c_function,
                                nargs: duk_idx_t, length: duk_idx_t,
                                magic: duk_int_t) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_thread_raw(ctx: *mut duk_context, flags: duk_uint_t)
     -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_proxy(ctx: *mut duk_context, proxy_flags: duk_uint_t)
     -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_error_object_raw(ctx: *mut duk_context,
                                     err_code: duk_errcode_t,
                                     filename: *const ::std::os::raw::c_char,
                                     line: duk_int_t,
                                     fmt: *const ::std::os::raw::c_char, ...)
     -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_error_object_va_raw(ctx: *mut duk_context,
                                        err_code: duk_errcode_t,
                                        filename:
                                            *const ::std::os::raw::c_char,
                                        line: duk_int_t,
                                        fmt: *const ::std::os::raw::c_char,
                                        ap: *mut __va_list_tag) -> duk_idx_t;
}
extern "C" {
    pub fn duk_push_buffer_raw(ctx: *mut duk_context, size: duk_size_t,
                               flags: duk_small_uint_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_push_buffer_object(ctx: *mut duk_context,
                                  idx_buffer: duk_idx_t,
                                  byte_offset: duk_size_t,
                                  byte_length: duk_size_t, flags: duk_uint_t);
}
extern "C" {
    pub fn duk_push_heapptr(ctx: *mut duk_context,
                            ptr: *mut ::std::os::raw::c_void) -> duk_idx_t;
}
extern "C" {
    pub fn duk_pop(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_pop_n(ctx: *mut duk_context, count: duk_idx_t);
}
extern "C" {
    pub fn duk_pop_2(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_pop_3(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_get_type(ctx: *mut duk_context, idx: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_check_type(ctx: *mut duk_context, idx: duk_idx_t,
                          type_: duk_int_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_type_mask(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_uint_t;
}
extern "C" {
    pub fn duk_check_type_mask(ctx: *mut duk_context, idx: duk_idx_t,
                               mask: duk_uint_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_undefined(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_null(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_boolean(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_number(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_nan(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_string(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_object(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_buffer(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_buffer_data(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_pointer(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_lightfunc(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_symbol(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_array(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_c_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_ecmascript_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_bound_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_thread(ctx: *mut duk_context, idx: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_constructable(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_dynamic_buffer(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_fixed_buffer(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_is_external_buffer(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_error_code(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_errcode_t;
}
extern "C" {
    pub fn duk_get_boolean(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_number(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_double_t;
}
extern "C" {
    pub fn duk_get_int(ctx: *mut duk_context, idx: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_get_uint(ctx: *mut duk_context, idx: duk_idx_t) -> duk_uint_t;
}
extern "C" {
    pub fn duk_get_string(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_get_lstring(ctx: *mut duk_context, idx: duk_idx_t,
                           out_len: *mut duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_get_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                          out_size: *mut duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_buffer_data(ctx: *mut duk_context, idx: duk_idx_t,
                               out_size: *mut duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_pointer(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_c_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_c_function;
}
extern "C" {
    pub fn duk_get_context(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut duk_context;
}
extern "C" {
    pub fn duk_get_heapptr(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_boolean_default(ctx: *mut duk_context, idx: duk_idx_t,
                                   def_value: duk_bool_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_number_default(ctx: *mut duk_context, idx: duk_idx_t,
                                  def_value: duk_double_t) -> duk_double_t;
}
extern "C" {
    pub fn duk_get_int_default(ctx: *mut duk_context, idx: duk_idx_t,
                               def_value: duk_int_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_get_uint_default(ctx: *mut duk_context, idx: duk_idx_t,
                                def_value: duk_uint_t) -> duk_uint_t;
}
extern "C" {
    pub fn duk_get_string_default(ctx: *mut duk_context, idx: duk_idx_t,
                                  def_value: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_get_lstring_default(ctx: *mut duk_context, idx: duk_idx_t,
                                   out_len: *mut duk_size_t,
                                   def_ptr: *const ::std::os::raw::c_char,
                                   def_len: duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_get_buffer_default(ctx: *mut duk_context, idx: duk_idx_t,
                                  out_size: *mut duk_size_t,
                                  def_ptr: *mut ::std::os::raw::c_void,
                                  def_len: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_buffer_data_default(ctx: *mut duk_context, idx: duk_idx_t,
                                       out_size: *mut duk_size_t,
                                       def_ptr: *mut ::std::os::raw::c_void,
                                       def_len: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_pointer_default(ctx: *mut duk_context, idx: duk_idx_t,
                                   def_value: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_get_c_function_default(ctx: *mut duk_context, idx: duk_idx_t,
                                      def_value: duk_c_function)
     -> duk_c_function;
}
extern "C" {
    pub fn duk_get_context_default(ctx: *mut duk_context, idx: duk_idx_t,
                                   def_value: *mut duk_context)
     -> *mut duk_context;
}
extern "C" {
    pub fn duk_get_heapptr_default(ctx: *mut duk_context, idx: duk_idx_t,
                                   def_value: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_opt_boolean(ctx: *mut duk_context, idx: duk_idx_t,
                           def_value: duk_bool_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_opt_number(ctx: *mut duk_context, idx: duk_idx_t,
                          def_value: duk_double_t) -> duk_double_t;
}
extern "C" {
    pub fn duk_opt_int(ctx: *mut duk_context, idx: duk_idx_t,
                       def_value: duk_int_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_opt_uint(ctx: *mut duk_context, idx: duk_idx_t,
                        def_value: duk_uint_t) -> duk_uint_t;
}
extern "C" {
    pub fn duk_opt_string(ctx: *mut duk_context, idx: duk_idx_t,
                          def_ptr: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_opt_lstring(ctx: *mut duk_context, idx: duk_idx_t,
                           out_len: *mut duk_size_t,
                           def_ptr: *const ::std::os::raw::c_char,
                           def_len: duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_opt_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                          out_size: *mut duk_size_t,
                          def_ptr: *mut ::std::os::raw::c_void,
                          def_size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_opt_buffer_data(ctx: *mut duk_context, idx: duk_idx_t,
                               out_size: *mut duk_size_t,
                               def_ptr: *mut ::std::os::raw::c_void,
                               def_size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_opt_pointer(ctx: *mut duk_context, idx: duk_idx_t,
                           def_value: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_opt_c_function(ctx: *mut duk_context, idx: duk_idx_t,
                              def_value: duk_c_function) -> duk_c_function;
}
extern "C" {
    pub fn duk_opt_context(ctx: *mut duk_context, idx: duk_idx_t,
                           def_value: *mut duk_context) -> *mut duk_context;
}
extern "C" {
    pub fn duk_opt_heapptr(ctx: *mut duk_context, idx: duk_idx_t,
                           def_value: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_require_undefined(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_require_null(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_require_boolean(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_require_number(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_double_t;
}
extern "C" {
    pub fn duk_require_int(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_int_t;
}
extern "C" {
    pub fn duk_require_uint(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_uint_t;
}
extern "C" {
    pub fn duk_require_string(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_require_lstring(ctx: *mut duk_context, idx: duk_idx_t,
                               out_len: *mut duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_require_object(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_require_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                              out_size: *mut duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_require_buffer_data(ctx: *mut duk_context, idx: duk_idx_t,
                                   out_size: *mut duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_require_pointer(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_require_c_function(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_c_function;
}
extern "C" {
    pub fn duk_require_context(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut duk_context;
}
extern "C" {
    pub fn duk_require_function(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_require_heapptr(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_to_undefined(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_to_null(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_to_boolean(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_to_number(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_double_t;
}
extern "C" {
    pub fn duk_to_int(ctx: *mut duk_context, idx: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_to_uint(ctx: *mut duk_context, idx: duk_idx_t) -> duk_uint_t;
}
extern "C" {
    pub fn duk_to_int32(ctx: *mut duk_context, idx: duk_idx_t) -> duk_int32_t;
}
extern "C" {
    pub fn duk_to_uint32(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_uint32_t;
}
extern "C" {
    pub fn duk_to_uint16(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_uint16_t;
}
extern "C" {
    pub fn duk_to_string(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_to_lstring(ctx: *mut duk_context, idx: duk_idx_t,
                          out_len: *mut duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_to_buffer_raw(ctx: *mut duk_context, idx: duk_idx_t,
                             out_size: *mut duk_size_t, flags: duk_uint_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_to_pointer(ctx: *mut duk_context, idx: duk_idx_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_to_object(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_to_primitive(ctx: *mut duk_context, idx: duk_idx_t,
                            hint: duk_int_t);
}
extern "C" {
    pub fn duk_safe_to_lstring(ctx: *mut duk_context, idx: duk_idx_t,
                               out_len: *mut duk_size_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_get_length(ctx: *mut duk_context, idx: duk_idx_t)
     -> duk_size_t;
}
extern "C" {
    pub fn duk_set_length(ctx: *mut duk_context, idx: duk_idx_t,
                          len: duk_size_t);
}
extern "C" {
    pub fn duk_base64_encode(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_base64_decode(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_hex_encode(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_hex_decode(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_json_encode(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_json_decode(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_buffer_to_string(ctx: *mut duk_context, idx: duk_idx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn duk_resize_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                             new_size: duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_steal_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                            out_size: *mut duk_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn duk_config_buffer(ctx: *mut duk_context, idx: duk_idx_t,
                             ptr: *mut ::std::os::raw::c_void,
                             len: duk_size_t);
}
extern "C" {
    pub fn duk_get_prop(ctx: *mut duk_context, obj_idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_prop_string(ctx: *mut duk_context, obj_idx: duk_idx_t,
                               key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_prop_lstring(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                key: *const ::std::os::raw::c_char,
                                key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_prop_index(ctx: *mut duk_context, obj_idx: duk_idx_t,
                              arr_idx: duk_uarridx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_prop_heapptr(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                ptr: *mut ::std::os::raw::c_void)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_prop(ctx: *mut duk_context, obj_idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_prop_string(ctx: *mut duk_context, obj_idx: duk_idx_t,
                               key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_prop_lstring(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                key: *const ::std::os::raw::c_char,
                                key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_prop_index(ctx: *mut duk_context, obj_idx: duk_idx_t,
                              arr_idx: duk_uarridx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_prop_heapptr(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                ptr: *mut ::std::os::raw::c_void)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_del_prop(ctx: *mut duk_context, obj_idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_del_prop_string(ctx: *mut duk_context, obj_idx: duk_idx_t,
                               key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_del_prop_lstring(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                key: *const ::std::os::raw::c_char,
                                key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_del_prop_index(ctx: *mut duk_context, obj_idx: duk_idx_t,
                              arr_idx: duk_uarridx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_del_prop_heapptr(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                ptr: *mut ::std::os::raw::c_void)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_has_prop(ctx: *mut duk_context, obj_idx: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_has_prop_string(ctx: *mut duk_context, obj_idx: duk_idx_t,
                               key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_has_prop_lstring(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                key: *const ::std::os::raw::c_char,
                                key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_has_prop_index(ctx: *mut duk_context, obj_idx: duk_idx_t,
                              arr_idx: duk_uarridx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_has_prop_heapptr(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                ptr: *mut ::std::os::raw::c_void)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_prop_desc(ctx: *mut duk_context, obj_idx: duk_idx_t,
                             flags: duk_uint_t);
}
extern "C" {
    pub fn duk_def_prop(ctx: *mut duk_context, obj_idx: duk_idx_t,
                        flags: duk_uint_t);
}
extern "C" {
    pub fn duk_get_global_string(ctx: *mut duk_context,
                                 key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_get_global_lstring(ctx: *mut duk_context,
                                  key: *const ::std::os::raw::c_char,
                                  key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_global_string(ctx: *mut duk_context,
                                 key: *const ::std::os::raw::c_char)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_put_global_lstring(ctx: *mut duk_context,
                                  key: *const ::std::os::raw::c_char,
                                  key_len: duk_size_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_inspect_value(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_inspect_callstack_entry(ctx: *mut duk_context,
                                       level: duk_int_t);
}
extern "C" {
    pub fn duk_get_prototype(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_set_prototype(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_get_finalizer(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_set_finalizer(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_set_global_object(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_get_magic(ctx: *mut duk_context, idx: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_set_magic(ctx: *mut duk_context, idx: duk_idx_t,
                         magic: duk_int_t);
}
extern "C" {
    pub fn duk_get_current_magic(ctx: *mut duk_context) -> duk_int_t;
}
extern "C" {
    pub fn duk_put_function_list(ctx: *mut duk_context, obj_idx: duk_idx_t,
                                 funcs: *const duk_function_list_entry);
}
extern "C" {
    pub fn duk_put_number_list(ctx: *mut duk_context, obj_idx: duk_idx_t,
                               numbers: *const duk_number_list_entry);
}
extern "C" {
    pub fn duk_compact(ctx: *mut duk_context, obj_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_enum(ctx: *mut duk_context, obj_idx: duk_idx_t,
                    enum_flags: duk_uint_t);
}
extern "C" {
    pub fn duk_next(ctx: *mut duk_context, enum_idx: duk_idx_t,
                    get_value: duk_bool_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_seal(ctx: *mut duk_context, obj_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_freeze(ctx: *mut duk_context, obj_idx: duk_idx_t);
}
extern "C" {
    pub fn duk_concat(ctx: *mut duk_context, count: duk_idx_t);
}
extern "C" {
    pub fn duk_join(ctx: *mut duk_context, count: duk_idx_t);
}
extern "C" {
    pub fn duk_decode_string(ctx: *mut duk_context, idx: duk_idx_t,
                             callback: duk_decode_char_function,
                             udata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_map_string(ctx: *mut duk_context, idx: duk_idx_t,
                          callback: duk_map_char_function,
                          udata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_substring(ctx: *mut duk_context, idx: duk_idx_t,
                         start_char_offset: duk_size_t,
                         end_char_offset: duk_size_t);
}
extern "C" {
    pub fn duk_trim(ctx: *mut duk_context, idx: duk_idx_t);
}
extern "C" {
    pub fn duk_char_code_at(ctx: *mut duk_context, idx: duk_idx_t,
                            char_offset: duk_size_t) -> duk_codepoint_t;
}
extern "C" {
    pub fn duk_equals(ctx: *mut duk_context, idx1: duk_idx_t, idx2: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_strict_equals(ctx: *mut duk_context, idx1: duk_idx_t,
                             idx2: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_samevalue(ctx: *mut duk_context, idx1: duk_idx_t,
                         idx2: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_instanceof(ctx: *mut duk_context, idx1: duk_idx_t,
                          idx2: duk_idx_t) -> duk_bool_t;
}
extern "C" {
    pub fn duk_call(ctx: *mut duk_context, nargs: duk_idx_t);
}
extern "C" {
    pub fn duk_call_method(ctx: *mut duk_context, nargs: duk_idx_t);
}
extern "C" {
    pub fn duk_call_prop(ctx: *mut duk_context, obj_idx: duk_idx_t,
                         nargs: duk_idx_t);
}
extern "C" {
    pub fn duk_pcall(ctx: *mut duk_context, nargs: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_pcall_method(ctx: *mut duk_context, nargs: duk_idx_t)
     -> duk_int_t;
}
extern "C" {
    pub fn duk_pcall_prop(ctx: *mut duk_context, obj_idx: duk_idx_t,
                          nargs: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_new(ctx: *mut duk_context, nargs: duk_idx_t);
}
extern "C" {
    pub fn duk_pnew(ctx: *mut duk_context, nargs: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_safe_call(ctx: *mut duk_context, func: duk_safe_call_function,
                         udata: *mut ::std::os::raw::c_void, nargs: duk_idx_t,
                         nrets: duk_idx_t) -> duk_int_t;
}
extern "C" {
    pub fn duk_eval_raw(ctx: *mut duk_context,
                        src_buffer: *const ::std::os::raw::c_char,
                        src_length: duk_size_t, flags: duk_uint_t)
     -> duk_int_t;
}
extern "C" {
    pub fn duk_compile_raw(ctx: *mut duk_context,
                           src_buffer: *const ::std::os::raw::c_char,
                           src_length: duk_size_t, flags: duk_uint_t)
     -> duk_int_t;
}
extern "C" {
    pub fn duk_dump_function(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_load_function(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_push_context_dump(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_debugger_attach(ctx: *mut duk_context,
                               read_cb: duk_debug_read_function,
                               write_cb: duk_debug_write_function,
                               peek_cb: duk_debug_peek_function,
                               read_flush_cb: duk_debug_read_flush_function,
                               write_flush_cb: duk_debug_write_flush_function,
                               request_cb: duk_debug_request_function,
                               detached_cb: duk_debug_detached_function,
                               udata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn duk_debugger_detach(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_debugger_cooperate(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_debugger_notify(ctx: *mut duk_context, nvalues: duk_idx_t)
     -> duk_bool_t;
}
extern "C" {
    pub fn duk_debugger_pause(ctx: *mut duk_context);
}
extern "C" {
    pub fn duk_get_now(ctx: *mut duk_context) -> duk_double_t;
}
extern "C" {
    pub fn duk_time_to_components(ctx: *mut duk_context,
                                  timeval: duk_double_t,
                                  comp: *mut duk_time_components);
}
extern "C" {
    pub fn duk_components_to_time(ctx: *mut duk_context,
                                  comp: *mut duk_time_components)
     -> duk_double_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
